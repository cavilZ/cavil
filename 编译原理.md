## 编译原理
编译过程  

* 预处理 
* 词法分析
* 语法分析
* 生成中间代码 
* 生成目标代码 
* 汇编 
* 链接

编译器：负责前五个步骤，编译器输入源代码，输出是中间代码

#### 词法分析
（认识每个单词） 

编译器知道每个单词，但是单词组合的语法还不懂
语法分析（模板匹配）        —>成功解析语法后，我们得到抽象语法树（AST），将源码转化为树状的数据结构，更容易被计算机解释和处理。但是距离中间代码还有一段距离。
####生成中间代码
（以GCC为例，生成中间代码分为三个步骤）

* 1.语法树转高端gimple 
处理寄存器和栈               				比如c = a + b       a+b结果保存到寄存器，然后寄存器赋值给c
* 2.高端gimple转低端gimple         		把变量定义，语句执行，返回语句区分存储
* 3.低端simple经过cya转ssa再转中间代码

* 生成中间代码是非常重要的一步，中间代码可以理解为一种非常抽象，又非常普适的代码。它客观中立描述代码要做的事情。中间代码某种意义上可以被理解为世界语。
另一方面，中间代码是编译器前端和后端的分界线。编译器前端负责把源码转换为中间代码，编译器后端把中间代码转换为汇编代码。

#### 生成目标代码 
—> 汇编代码 —> 汇编器会接收汇编代码，转换为二进制机器码，生成目标文件（.o）

### 链接

#### 预处理         
 —> 处理一些宏定义，比如#define #include     预处理:有些编译器在词法分析前先预处理，替换掉宏。有些则是分析到#开头，才进行替换。实际上GCC是第二种。

编译VS解释

* 总结一下，对于 C 语言来说，从源码到运行结果大致上需要经历编译、汇编和链接三个步骤。编译器接收源代码，输出目标代码(也就是汇编代码)，汇编器接收汇编代码，输出由机器码组成的目标文件(二进制格式，.o 后缀)，最后链接器将各个目标文件链接起来，执行重定位，最终生成可执行文件。
编译器以中间代码为界限，又可以分前端和后端。比如 clang 就是一个前端工具，而 LLVM 则负责后端处理。另一个知名工具 GCC(GNU Compile Collection)则是一个套装，包揽了前后端的所有任务。前端主要负责预处理、词法分析、语法分析，最终生成语言无关的中间代码。后端主要负责目标代码的生成和优化。

解释型语言

* 源代码 -> 解释器 -> 运行结果

编译

* 源代码 -> 中间代码 -> 目标代码 -> 运行结果

* 规范和实现是两套分离的体系。我们平常说的 C 语言的语法，实际上是一套规范。理论上来说每个人都可以写出自己的编译器来实现 C 语言，只要你的编译器能够正确运行，最终的输出结果正确即可。而编译型和解释型说的其实是语言的实现方案，是提前编译以获得最大的性能提高，还是运行时去解析以获得灵活性，往往取决于语言的应用场景。所以说一门语言是编译型还是解释型的，这会非常可笑。一个标准怎么可能会有固定的实现呢？之所以给大家留下了 C 语言是编译型语言，Python 是解释型语言的印象，往往是因为这门语言的应用场景决定了它是主流实现是编译型还是解释型。

自举

* C 语言的编译器是如何实现的？实际上它还是用 C 语言实现的。这种自己能编译自己的神奇能力被称为自举(Bootstrap)。
实现：就是不断用低级语言来写高级语言的编译器，
所以一门语言能不能自举，主要取决于它的实现形式能否被编译并留下二进制格式的可执行文件。

运行时 JIT 优化

* 解释执行效率低的主要原因之一在于，相同的语句被反复解释，因此优化的思路是动态的观察哪些代码是经常被调用的。对于那些被高频率调用的代码，可以用编译器把它编译成机器码并且缓存下来，下次执行的时候就不用重新解释，从而提升速度。这就是 JIT(Just-In-Time) 的技术原理。

跨语言那些事儿

* 对于一个常见的可以由某个语言完成的任务(比如 JavaScript 写网页)，能不能换一个语言来实现(比如 C++)，如果不能，制约因素在哪里”。

直接语法转换

* 从源码转换到中间代码需要使用编译器，从中间代码转换到源码则使用反编译器。

实现单纯语法的转换意义并不大

* 1.对于图灵完备的语言来说，换一种表示方法(语言)去解决相同的问题并没有意义。
* 2.语言的真正功能绝不仅仅是语法本身，而在于它的运行时环境提供了什么样的功能。
凡是在语言层面进行强制转换的，要么利用反编译器拿到一堆格式正确但无法运行的代码，要么就自行解析语法树并为转换后的语言添加对应的能力，来实现转换前语言的功能。

胶水语言 Python

* Python 一个很强大的特点是胶水语言，可以把 Python 理解为各种语言的粘合剂
由于在 Mac OS X 系统上，Python 解释器是一个动态链接库，所以只要导入一下头文件即可

OCS ——史上最疯狂的 iOS 动态化方案

* 腾讯 OCS 的实现原理：OCS 是一个 Objective-C 解释器。
